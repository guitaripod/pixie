use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use worker::{Env, Result, Fetch, Request as WorkerRequest, Method, Headers};
use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};
use crate::error::AppError;
use crate::deployment::{DeploymentConfig, DeploymentMode};
use super::{ImageProvider, UnifiedImageRequest, UnifiedEditRequest, ProviderResponse, ImageBytes, CostEstimate, ProviderFeatures};
use crate::models::ImageUsage;

const GEMINI_API_URL: &str = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent";
const GEMINI_CREDITS_PER_IMAGE: u32 = 15;
const CREDIT_MULTIPLIER: f64 = 3.0;

#[derive(Debug, Clone, Serialize, Deserialize)]
struct GeminiRequest {
    contents: Vec<GeminiContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct GeminiContent {
    parts: Vec<GeminiPart>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
enum GeminiPart {
    Text { text: String },
    Image { 
        #[serde(rename = "inlineData")]
        inline_data: InlineData 
    },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct InlineData {
    #[serde(rename = "mimeType")]
    mime_type: String,
    data: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct GeminiResponse {
    candidates: Vec<GeminiCandidate>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct GeminiCandidate {
    content: GeminiContent,
}

pub struct GeminiProvider {
    api_key: String,
}

impl GeminiProvider {
    pub fn new(env: &Env) -> Result<Self> {
        let deployment_config = DeploymentConfig::from_env(env)
            .map_err(|e| worker::Error::from(AppError::InternalError(format!("Deployment config error: {:?}", e))))?;

        let api_key = match deployment_config.mode {
            DeploymentMode::Official => {
                env.secret("GEMINI_API_KEY")
                    .map_err(|_| worker::Error::RustError("GEMINI_API_KEY not configured".to_string()))?
                    .to_string()
            }
            DeploymentMode::SelfHosted => {
                return Err(worker::Error::RustError("Self-hosted Gemini not supported yet".to_string()));
            }
        };

        Ok(Self { api_key })
    }

    pub fn with_api_key(api_key: String) -> Self {
        Self { api_key }
    }

    async fn call_gemini_api(&self, request_body: GeminiRequest) -> Result<GeminiResponse> {
        let headers = Headers::new();
        headers.set("x-goog-api-key", &self.api_key)?;
        headers.set("Content-Type", "application/json")?;

        let mut init = worker::RequestInit::new();
        init.with_method(Method::Post)
            .with_headers(headers)
            .with_body(Some(worker::wasm_bindgen::JsValue::from_str(&serde_json::to_string(&request_body)?)));

        let request = WorkerRequest::new_with_init(GEMINI_API_URL, &init)?;
        let mut response = Fetch::Request(request).send().await?;

        if response.status_code() >= 400 {
            let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
            return Err(AppError::InternalError(format!("Gemini API error: {}", error_text)).into());
        }

        let gemini_response: GeminiResponse = response.json().await
            .map_err(|e| AppError::InternalError(format!("Failed to parse Gemini response: {}", e)))?;

        Ok(gemini_response)
    }
}

#[async_trait(?Send)]
impl ImageProvider for GeminiProvider {
    async fn generate_image(&self, request: &UnifiedImageRequest) -> Result<ProviderResponse> {
        let n = request.n.unwrap_or(1);
        let mut all_images = Vec::new();
        let mut all_prompts = Vec::new();

        for _ in 0..n {
            let gemini_request = GeminiRequest {
                contents: vec![GeminiContent {
                    parts: vec![GeminiPart::Text { text: request.prompt.clone() }],
                }],
            };

            let response = self.call_gemini_api(gemini_request).await?;

            if response.candidates.is_empty() {
                return Err(AppError::InternalError("No image generated by Gemini".to_string()).into());
            }

            for candidate in response.candidates {
                for part in candidate.content.parts {
                    match part {
                        GeminiPart::Image { inline_data } => {
                            let image_data = BASE64.decode(&inline_data.data)
                                .map_err(|e| AppError::InternalError(format!("Failed to decode image: {}", e)))?;
                            
                            let format = match inline_data.mime_type.as_str() {
                                "image/png" => "png",
                                "image/jpeg" => "jpeg",
                                _ => "png",
                            };

                            all_images.push(ImageBytes {
                                data: image_data,
                                format: format.to_string(),
                            });
                            all_prompts.push(Some(request.prompt.clone()));
                        }
                        GeminiPart::Text { .. } => {
                            // Skip text parts in the response
                        }
                    }
                }
            }
        }

        if all_images.is_empty() {
            return Err(AppError::InternalError("No images returned by Gemini".to_string()).into());
        }

        let usage = Some(ImageUsage {
            total_tokens: 1000,
            input_tokens: 500,
            output_tokens: 500,
            input_tokens_details: crate::models::InputTokenDetails {
                text_tokens: 500,
                image_tokens: 0,
            },
        });

        Ok(ProviderResponse {
            images: all_images,
            usage,
            revised_prompts: all_prompts,
        })
    }

    async fn edit_image(&self, request: &UnifiedEditRequest) -> Result<ProviderResponse> {
        if request.image.is_empty() {
            return Err(AppError::BadRequest("No input image provided".to_string()).into());
        }

        let n = request.n.unwrap_or(1);
        let mut all_images = Vec::new();
        let mut all_prompts = Vec::new();

        let input_image_data = if request.image[0].starts_with("data:") {
            let parts: Vec<&str> = request.image[0].split(',').collect();
            if parts.len() != 2 {
                return Err(AppError::BadRequest("Invalid image data URL".to_string()).into());
            }
            parts[1].to_string()
        } else {
            request.image[0].clone()
        };

        for _ in 0..n {
            let gemini_request = GeminiRequest {
                contents: vec![GeminiContent {
                    parts: vec![
                        GeminiPart::Text { text: request.prompt.clone() },
                        GeminiPart::Image {
                            inline_data: InlineData {
                                mime_type: "image/jpeg".to_string(),
                                data: input_image_data.clone(),
                            },
                        },
                    ],
                }],
            };

            let response = self.call_gemini_api(gemini_request).await?;

            if response.candidates.is_empty() {
                return Err(AppError::InternalError("No image generated by Gemini".to_string()).into());
            }

            for candidate in response.candidates {
                for part in candidate.content.parts {
                    match part {
                        GeminiPart::Image { inline_data } => {
                            let image_data = BASE64.decode(&inline_data.data)
                                .map_err(|e| AppError::InternalError(format!("Failed to decode image: {}", e)))?;
                            
                            let format = match inline_data.mime_type.as_str() {
                                "image/png" => "png",
                                "image/jpeg" => "jpeg",
                                _ => "png",
                            };

                            all_images.push(ImageBytes {
                                data: image_data,
                                format: format.to_string(),
                            });
                            all_prompts.push(Some(request.prompt.clone()));
                        }
                        GeminiPart::Text { .. } => {
                            // Skip text parts in the response
                        }
                    }
                }
            }
        }

        if all_images.is_empty() {
            return Err(AppError::InternalError("No images returned by Gemini".to_string()).into());
        }

        let usage = Some(ImageUsage {
            total_tokens: 1500,
            input_tokens: 750,
            output_tokens: 750,
            input_tokens_details: crate::models::InputTokenDetails {
                text_tokens: 250,
                image_tokens: 500,
            },
        });

        Ok(ProviderResponse {
            images: all_images,
            usage,
            revised_prompts: all_prompts,
        })
    }

    fn estimate_cost(&self, request: &UnifiedImageRequest) -> CostEstimate {
        let n = request.n.unwrap_or(1) as u32;
        CostEstimate {
            credits: GEMINI_CREDITS_PER_IMAGE * n,
            provider: "gemini".to_string(),
        }
    }

    fn estimate_edit_cost(&self, _request: &UnifiedEditRequest) -> CostEstimate {
        let n = _request.n.unwrap_or(1) as u32;
        CostEstimate {
            credits: GEMINI_CREDITS_PER_IMAGE * n,
            provider: "gemini".to_string(),
        }
    }

    fn get_supported_features(&self) -> ProviderFeatures {
        ProviderFeatures {
            supports_size: false,
            supports_quality: false,
            supports_background: false,
            supports_moderation: false,
            supports_edit: true,
            supports_multiple_outputs: true,
            max_outputs: 8,
        }
    }

    fn get_name(&self) -> &str {
        "gemini"
    }
}